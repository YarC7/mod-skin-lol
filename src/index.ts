import { app, BrowserWindow, dialog, ipcMain } from "electron";
import { spawn } from "child_process";
import * as fs from "fs";
import * as path from "path";
import log from "electron-log";

// Setup logging
log.transports.file.level = "info";
log.transports.console.level = "debug";
log.transports.file.maxSize = 5 * 1024 * 1024; // 5MB
log.info("App starting...");

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  log.info("Squirrel startup event, quitting...");
  app.quit();
}

type FileDialogResult = { canceled: true } | { canceled: false; path: string };
type LaunchResult = { success: boolean; message?: string };

const SETTINGS_FILE = path.join(app.getPath("userData"), "settings.json");

const getResourcePath = (filename: string) => {
  return app.isPackaged
    ? path.join(process.resourcesPath, filename)
    : path.join(app.getAppPath(), filename);
};

type Settings = {
  managerPath: string;
  skinsRepoPath: string;
  gamePath?: string;
};

const registerIpcHandlers = (): void => {
  ipcMain.handle("launcher:select-folder", async (): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select Folder",
      properties: ["openDirectory"],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:select-file", async (_event, filters: any): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select File",
      properties: ["openFile"],
      filters: filters,
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:save-settings", async (_event, settings: Settings) => {
    fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    return true;
  });

  ipcMain.handle("launcher:load-settings", async (): Promise<Settings> => {
    if (fs.existsSync(SETTINGS_FILE)) {
      return JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    }
    return { managerPath: "", skinsRepoPath: "" };
  });

  ipcMain.handle("launcher:find-mod-file", async (_event, championId: string, skinNameEn: string, skinNum: number): Promise<string | null> => {
    if (!fs.existsSync(SETTINGS_FILE)) return null;
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return null;

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return null;

    const files = fs.readdirSync(champDir);

    // 1. Try exact match with En name
    const exactMatch = files.find(f => f.toLowerCase() === `${skinNameEn.toLowerCase()}.zip` || f.toLowerCase() === `${skinNameEn.toLowerCase()}.fantome`);
    if (exactMatch) return path.join(champDir, exactMatch);

    // 2. Default skin (index 0)
    if (skinNum === 0) {
      const defaultFile = files.find(f => f.toLowerCase() === `${championId.toLowerCase()}.zip` || f.toLowerCase() === `${championId.toLowerCase()}.fantome`);
      if (defaultFile) return path.join(champDir, defaultFile);
    }

    // 3. Fallback: Check if file contains the skin name parts
    const partialMatch = files.find(f => {
      const lowerF = f.toLowerCase();
      const lowerName = skinNameEn.toLowerCase();
      return (lowerF.includes(lowerName) || lowerName.includes(lowerF.replace(/\.(zip|fantome)$/, ""))) && (f.endsWith(".zip") || f.endsWith(".fantome"));
    });

    if (partialMatch) return path.join(champDir, partialMatch);

    return null;
  });

  ipcMain.handle("launcher:list-mod-files", async (_event, championId: string): Promise<string[]> => {
    if (!fs.existsSync(SETTINGS_FILE)) return [];
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return [];

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return [];

    return fs.readdirSync(champDir)
      .filter(f => f.endsWith(".zip") || f.endsWith(".fantome"))
      .map(f => path.join(champDir, f));
  });

  ipcMain.handle("launcher:get-game-path", async () => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return "";
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));

      if (settings.gamePath && fs.existsSync(settings.gamePath)) {
        return settings.gamePath;
      }
      if (settings.gamePath) {
        delete settings.gamePath;
      }

      if (!settings.managerPath) return "";

      let detectedPath = "";

      const configIniPath = path.join(settings.managerPath, "config.ini");
      if (fs.existsSync(configIniPath)) {
        const content = fs.readFileSync(configIniPath, "utf-8");
        const match = content.match(/leaguePath\s*=\s*([^\r\n]+)/i);
        if (match && match[1]) {
          detectedPath = match[1].trim().replace(/^["'](.*)["']$/, '$1');
        }
      }

      if (!detectedPath) {
        const configYamlPath = path.join(settings.managerPath, "config.yaml");
        if (fs.existsSync(configYamlPath)) {
          const content = fs.readFileSync(configYamlPath, "utf-8");
          const match = content.match(/game(?:Path|_path|path)?\s*:\s*["']?(.*?)["']?\s*$/mi);
          if (match && match[1]) detectedPath = match[1].trim();
        }
      }

      if (detectedPath && detectedPath !== '""' && detectedPath !== "''") {
        settings.gamePath = detectedPath;
        fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
        return detectedPath;
      }
    } catch (e) {
      log.error("System: Error detecting game path:", e);
    }
    return "";
  });

  ipcMain.handle("launcher:run-mod-tools", async (_event, command: string, args: string[]) => {
    try {
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) throw new Error("Manager path not set");

      const toolsExe = path.join(settings.managerPath, "cslol-tools", "mod-tools.exe");
      if (!fs.existsSync(toolsExe)) throw new Error("mod-tools.exe not found");

      const processedArgs = args.map(arg => arg.replace(/\//g, "\\"));

      return new Promise((resolve) => {
        const child = spawn(toolsExe, [command, ...processedArgs], {
          cwd: settings.managerPath,
          shell: false,
          windowsHide: true
        });

        let stdout = "";
        let stderr = "";

        child.stdout.on("data", (data) => (stdout += data.toString()));
        child.stderr.on("data", (data) => (stderr += data.toString()));

        child.on("close", (code) => {
          if (code === 0) {
            resolve({ success: true, stdout, stderr });
          } else {
            resolve({ success: false, stdout, stderr, code });
          }
        });
      });
    } catch (e: any) {
      return { success: false, stderr: e.message };
    }
  });

  ipcMain.handle("launcher:kill-manager", async () => {
    const { exec } = require("child_process");
    return new Promise((resolve) => {
      exec('taskkill /F /IM cslol-manager.exe /T', () => {
        resolve(true);
      });
    });
  });

  ipcMain.handle("launcher:start-manager", async () => {
    try {
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) throw new Error("Manager path not set");

      const managerExe = path.join(settings.managerPath, "cslol-manager.exe");
      if (!fs.existsSync(managerExe)) throw new Error("cslol-manager.exe not found");

      const { exec } = require("child_process");

      return new Promise((resolve) => {
        exec('tasklist', (err: any, stdout: string) => {
          const isRunning = stdout.toLowerCase().includes("cslol-manager.exe");

          if (isRunning) {
            log.info("CS-LOL Manager already running");
            resolve(true);
          } else {
            // Dùng spawn detached để không đợi GUI app kết thúc
            const child = spawn(managerExe, [], {
              detached: true,
              stdio: 'ignore',
              cwd: settings.managerPath,
              windowsHide: false
            });

            child.unref(); // Cho phép parent process thoát mà không đợi child

            log.info("CS-LOL Manager started successfully");
            resolve(true);
          }
        });
      });
    } catch (e: any) {
      log.error("Error starting manager:", e);
      throw e;
    }
  });

  ipcMain.handle("launcher:clear-mods", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const installedDir = path.join(settings.managerPath, "installed");
    if (fs.existsSync(installedDir)) {
      const files = fs.readdirSync(installedDir);
      for (const file of files) {
        const fullPath = path.join(installedDir, file);
        try {
          if (fs.lstatSync(fullPath).isDirectory()) {
            fs.rmSync(fullPath, { recursive: true, force: true });
          } else {
            fs.unlinkSync(fullPath);
          }
        } catch (e) {
          log.error(`Could not delete ${file}:`, e);
        }
      }
    }
    return true;
  });

  ipcMain.handle("launcher:enable-mod-in-profile", async (_event, modName: string) => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return false;
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return false;

      const profilesDir = path.join(settings.managerPath, "profiles");
      if (!fs.existsSync(profilesDir)) return false;

      const files = fs.readdirSync(profilesDir);

      for (const file of files) {
        const fullPath = path.join(profilesDir, file);
        const lowerFile = file.toLowerCase();

        if (lowerFile.endsWith(".profile")) {
          fs.writeFileSync(fullPath, modName + "\n");
        } else if (lowerFile.endsWith(".config") || lowerFile.endsWith(".json")) {
          try {
            let config: any = { mods: {} };
            const content = fs.readFileSync(fullPath, "utf-8");
            if (content.trim()) {
              try { config = JSON.parse(content); } catch (e) { /* ignore */ }
            }
            config.mods = {};
            config.mods[modName] = true;
            fs.writeFileSync(fullPath, JSON.stringify(config, null, 2));
          } catch (e) { log.warn("Error writing config:", e); }
        } else if (fs.lstatSync(fullPath).isDirectory()) {
          const yamlPath = path.join(fullPath, "config.yaml");
          if (fs.existsSync(yamlPath)) {
            let content = fs.readFileSync(yamlPath, "utf-8");
            if (content.includes("mods:")) {
              content = content.replace(/mods:[\s\S]*?(?=\n\w|$)/, `mods:\n  ${modName}: true`);
            } else {
              content += `\nmods:\n  ${modName}: true`;
            }
            fs.writeFileSync(yamlPath, content);
          }
        }
      }
      return true;
    } catch (e) {
      log.error("Error in enable-mod-in-profile:", e);
      return false;
    }
  });

  ipcMain.handle("launcher:get-profile-paths", async () => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return null;
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return null;

      const profilesDir = path.join(settings.managerPath, "profiles");
      if (!fs.existsSync(profilesDir)) return null;

      const names = ["Default Profile", "Default"];
      for (const name of names) {
        const folderPath = path.join(profilesDir, name);
        const configPath = path.join(profilesDir, `${name}.config`);
        const jsonPath = path.join(profilesDir, `${name}.json`);

        let foundConfig = "";
        if (fs.existsSync(configPath)) foundConfig = configPath;
        else if (fs.existsSync(jsonPath)) foundConfig = jsonPath;

        if (fs.existsSync(folderPath) || foundConfig) {
          return {
            name: name,
            folder: folderPath,
            config: foundConfig
          };
        }
      }
    } catch (e) {
      log.error("Error getting profile paths:", e);
    }
    return null;
  });

  ipcMain.handle("launcher:log", (_event, level: string, message: string) => {
    switch (level.toLowerCase()) {
      case "error":
        log.error(message);
        break;
      case "warn":
        log.warn(message);
        break;
      case "info":
      default:
        log.info(message);
        break;
    }
  });

  ipcMain.handle("launcher:get-log-path", () => {
    return log.transports.file.getFile().path;
  });

  ipcMain.handle("launcher:check-for-updates", async () => {
    return { success: false, message: "Auto-update disabled" };
  });

  ipcMain.handle(
    "load-champions",
    async (): Promise<any[]> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        if (!fs.existsSync(filePath)) {
          log.error("Champion data file NOT FOUND at:", filePath);
          return [];
        }
        const data = fs.readFileSync(filePath, "utf-8");
        const allData = JSON.parse(data);
        return allData.map((item: any) => ({
          id: item.id,
          name_en: item.name_en,
          name_vi: item.name_vi
        }));
      } catch (error) {
        log.error("Error loading champions:", error);
        return [];
      }
    },
  );

  ipcMain.handle(
    "load-skins",
    async (_event, championId: string): Promise<any> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        const data = fs.readFileSync(filePath, "utf-8");
        const allSkins = JSON.parse(data);
        return allSkins.find((item: any) => item.id === championId) || null;
      } catch (error) {
        log.error("Error loading skins:", error);
        return null;
      }
    }
  );
};

const createWindow = (): void => {
  log.info("Creating main window...");
  const mainWindow = new BrowserWindow({
    height: 640,
    width: 960,
    minHeight: 560,
    minWidth: 900,
    autoHideMenuBar: true,
    backgroundColor: "#05060d",
    title: "CS-LOL Launcher",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      sandbox: false,
      webSecurity: false,
    },
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools({ mode: "detach" });
  }

  log.info("Main window created successfully");
};

app.whenReady().then(() => {
  log.info("App ready, registering IPC handlers...");
  registerIpcHandlers();
  createWindow();

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      log.info("Activating app, creating new window...");
      createWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    log.info("All windows closed, quitting app...");
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
