import { app, BrowserWindow, dialog, ipcMain } from "electron";
import { autoUpdater } from "electron-updater";
import { spawn } from "child_process";
import * as fs from "fs";
import * as path from "path";
import log from "electron-log";

// Cấu hình log
log.transports.file.level = "info";
log.initialize({ spyRendererConsole: true }); // Tự động bắt log từ renderer

log.info("App starting...");
log.info("Version:", app.getVersion());
const logPath = log.transports.file.getFile().path;
log.info("Log file located at:", logPath);
console.log("\n\x1b[32m[LOG PATH]\x1b[0m", logPath, "\n"); // Hiển thị rõ trong CMD
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const SETTINGS_FILE = path.join(app.getPath("userData"), "settings.json");

const getResourcePath = (filename: string) => {
  return app.isPackaged
    ? path.join(process.resourcesPath, filename)
    : path.join(app.getAppPath(), filename);
};

type Settings = {
  managerPath: string;
  skinsRepoPath: string;
  gamePath?: string; // Thêm trường cache đường dẫn game
};

type FileDialogResult = { canceled: true } | { canceled: false; path: string };
type LaunchResult = { success: boolean; message?: string };
const registerIpcHandlers = (): void => {
  ipcMain.handle("launcher:select-folder", async (): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select Folder",
      properties: ["openDirectory"],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:select-file", async (_event, filters: any): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select File",
      properties: ["openFile"],
      filters: filters,
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:log", (_event, level: string, message: string) => {
    (log as any)[level](message);
  });

  ipcMain.handle("launcher:save-settings", async (_event, settings: Settings) => {
    fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    return true;
  });

  ipcMain.handle("launcher:load-settings", async (): Promise<Settings> => {
    if (fs.existsSync(SETTINGS_FILE)) {
      return JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    }
    return { managerPath: "", skinsRepoPath: "" };
  });

  ipcMain.handle("launcher:find-mod-file", async (_event, championId: string, skinNameEn: string, skinNum: number): Promise<string | null> => {
    if (!fs.existsSync(SETTINGS_FILE)) return null;
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return null;

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return null;

    const files = fs.readdirSync(champDir);

    // 1. Try exact match with En name (e.g. "Justicar Aatrox.zip")
    const exactMatch = files.find(f => f.toLowerCase() === `${skinNameEn.toLowerCase()}.zip` || f.toLowerCase() === `${skinNameEn.toLowerCase()}.fantome`);
    if (exactMatch) return path.join(champDir, exactMatch);

    // 2. Default skin (index 0)
    if (skinNum === 0) {
      const defaultFile = files.find(f => f.toLowerCase() === `${championId.toLowerCase()}.zip` || f.toLowerCase() === `${championId.toLowerCase()}.fantome`);
      if (defaultFile) return path.join(champDir, defaultFile);
    }

    // 3. Fallback: Check if file contains the skin name parts
    const partialMatch = files.find(f => {
      const lowerF = f.toLowerCase();
      const lowerName = skinNameEn.toLowerCase();
      return (lowerF.includes(lowerName) || lowerName.includes(lowerF.replace(/\.(zip|fantome)$/, ""))) && (f.endsWith(".zip") || f.endsWith(".fantome"));
    });

    if (partialMatch) return path.join(champDir, partialMatch);

    return null;
  });

  ipcMain.handle("launcher:list-mod-files", async (_event, championId: string): Promise<string[]> => {
    if (!fs.existsSync(SETTINGS_FILE)) return [];
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return [];

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return [];

    return fs.readdirSync(champDir)
      .filter(f => f.endsWith(".zip") || f.endsWith(".fantome"))
      .map(f => path.join(champDir, f));
  });

  ipcMain.handle("launcher:get-game-path", async () => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return "";
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));

      // 1. Nếu đã có trong cache settings, ưu tiên dùng luôn (nếu tồn tại trên ổ đĩa)
      if (settings.gamePath && fs.existsSync(settings.gamePath)) {
        log.info("System: Using cached Game Path:", settings.gamePath);
        return settings.gamePath;
      }
      if (settings.gamePath) {
        log.warn("System: Cached Game Path no longer exists, re-detecting...");
        delete settings.gamePath;
      }

      if (!settings.managerPath) return "";

      let detectedPath = "";

      // 2. Thử tìm trong config.ini (Ưu tiên vì user đang dùng file này)
      const configIniPath = path.join(settings.managerPath, "config.ini");
      if (fs.existsSync(configIniPath)) {
        log.info("System: Reading config.ini at:", configIniPath);
        const content = fs.readFileSync(configIniPath, "utf-8");
        // Regex thoáng hơn, không bắt đầu ở đầu dòng ^ để tránh vấn đề với BOM hoặc byte lạ
        const match = content.match(/leaguePath\s*=\s*([^\r\n]+)/i);
        if (match && match[1]) {
          detectedPath = match[1].trim().replace(/^["'](.*)["']$/, '$1');
          log.info("System: Detected leaguePath from INI:", detectedPath);
        }
      }

      // 3. Thử tìm trong config.yaml (Dự phòng)
      if (!detectedPath) {
        const configYamlPath = path.join(settings.managerPath, "config.yaml");
        if (fs.existsSync(configYamlPath)) {
          const content = fs.readFileSync(configYamlPath, "utf-8");
          const match = content.match(/game(?:Path|_path|path)?\s*:\s*["']?(.*?)["']?\s*$/mi);
          if (match && match[1]) detectedPath = match[1].trim();
        }
      }

      // Nếu tìm thấy, lưu vào cache để lần sau không phải quét lại
      if (detectedPath && detectedPath !== '""' && detectedPath !== "''") {
        settings.gamePath = detectedPath;
        fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
        log.info("System: Saved Game Path to settings cache.");
        return detectedPath;
      } else {
        log.warn("System: Could not detect game path from any config file.");
      }
    } catch (e) {
      log.error("System: Error detecting game path:", e);
    }
    return "";
  });

  ipcMain.handle("launcher:run-mod-tools", async (_event, command: string, args: string[]) => {
    try {
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) throw new Error("Manager path not set");

      const toolsExe = path.join(settings.managerPath, "cslol-tools", "mod-tools.exe");
      if (!fs.existsSync(toolsExe)) throw new Error("mod-tools.exe not found");

      log.info(`System: Spawning mod-tools ${command} with args:`, args);

      // Sử dụng shell: true để giúp xử lý khoảng trắng trong đường dẫn tốt hơn trên Windows
      return new Promise((resolve) => {
        const child = spawn(toolsExe, [command, ...args], {
          cwd: settings.managerPath,
          shell: true,
          windowsHide: true
        });

        let stdout = "";
        let stderr = "";

        child.stdout.on("data", (data) => (stdout += data.toString()));
        child.stderr.on("data", (data) => (stderr += data.toString()));

        child.on("close", (code) => {
          if (code === 0) {
            resolve({ success: true, stdout, stderr });
          } else {
            log.error(`System: mod-tools failed (code ${code}). Stderr: ${stderr}`);
            resolve({ success: false, stdout, stderr, code });
          }
        });
      });
    } catch (e: any) {
      log.error("System: Error in run-mod-tools:", e);
      return { success: false, stderr: e.message };
    }
  });

  ipcMain.handle("launcher:kill-manager", async () => {
    const { exec } = require("child_process");
    return new Promise((resolve) => {
      // /F: Force kill, /IM: Image Name, /T: Kill child processes
      exec('taskkill /F /IM cslol-manager.exe /T', () => {
        // Luôn resolve true kể cả khi nó không chạy (lỗi thoát code 128)
        resolve(true);
      });
    });
  });

  ipcMain.handle("launcher:start-manager", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const managerExe = path.join(settings.managerPath, "cslol-manager.exe");
    if (!fs.existsSync(managerExe)) throw new Error("cslol-manager.exe not found");

    const { exec } = require("child_process");

    log.info("Manager: Starting GUI...");
    // Kiểm tra xem tiến trình có đang chạy không
    return new Promise((resolve) => {
      exec('tasklist', (err: any, stdout: string) => {
        const isRunning = stdout.toLowerCase().includes("cslol-manager.exe");

        if (isRunning) {
          log.info("Manager: Already running.");
          resolve(true);
        } else {
          exec(`"${managerExe}"`, (startErr: any) => {
            if (startErr) log.error("Manager: Failed to start GUI:", startErr);
            else log.info("Manager: GUI started successfully.");
            resolve(true);
          });
        }
      });
    });
  });

  ipcMain.handle("launcher:clear-mods", async () => {
    log.info("System: Clearing installed mods...");
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const installedDir = path.join(settings.managerPath, "installed");
    if (fs.existsSync(installedDir)) {
      const files = fs.readdirSync(installedDir);
      for (const file of files) {
        const fullPath = path.join(installedDir, file);
        try {
          if (fs.lstatSync(fullPath).isDirectory()) {
            fs.rmSync(fullPath, { recursive: true, force: true });
          } else {
            fs.unlinkSync(fullPath);
          }
        } catch (e) {
          log.error(`System: Could not delete ${file}:`, e);
        }
      }
    }
    log.info("System: Installed mods cleared.");
    return true;
  });

  ipcMain.handle("launcher:enable-mod-in-profile", async (_event, modName: string) => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return false;
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return false;

      const profilesDir = path.join(settings.managerPath, "profiles");
      if (!fs.existsSync(profilesDir)) return false;

      // Tìm tất cả các file liên quan đến profile (Default, Default Profile, v.v.)
      const files = fs.readdirSync(profilesDir);

      for (const file of files) {
        const fullPath = path.join(profilesDir, file);
        const lowerFile = file.toLowerCase();

        // 1. Xử lý file .profile (Dạng text thuần, mỗi dòng 1 tên mod)
        if (lowerFile.endsWith(".profile")) {
          console.log(`Updating .profile file: ${file}`);
          fs.writeFileSync(fullPath, modName + "\n");
        }

        // 2. Xử lý file .config hoặc .json (Dạng JSON)
        else if (lowerFile.endsWith(".config") || lowerFile.endsWith(".json")) {
          console.log(`Updating JSON config: ${file}`);
          try {
            let config: any = { mods: {} };
            const content = fs.readFileSync(fullPath, "utf-8");
            if (content.trim()) {
              try { config = JSON.parse(content); } catch (e) { /* ignore */ }
            }
            config.mods = {};
            config.mods[modName] = true;
            fs.writeFileSync(fullPath, JSON.stringify(config, null, 2));
          } catch (e) { console.warn(e); }
        }

        // 3. Xử lý thư mục profile (Chứa config.yaml bên trong)
        else if (fs.lstatSync(fullPath).isDirectory()) {
          const yamlPath = path.join(fullPath, "config.yaml");
          if (fs.existsSync(yamlPath)) {
            console.log(`Updating YAML config in folder: ${file}`);
            let content = fs.readFileSync(yamlPath, "utf-8");
            if (content.includes("mods:")) {
              content = content.replace(/mods:[\s\S]*?(?=\n\w|$)/, `mods:\n  ${modName}: true`);
            } else {
              content += `\nmods:\n  ${modName}: true`;
            }
            fs.writeFileSync(yamlPath, content);
          }
        }
      }
      return true;
    } catch (e) {
      console.error("Error in enable-mod-in-profile:", e);
      return false;
    }
  });

  ipcMain.handle("launcher:get-profile-paths", async () => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return null;
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return null;

      const profilesDir = path.join(settings.managerPath, "profiles");
      if (!fs.existsSync(profilesDir)) return null;

      // Ưu tiên "Default Profile" sau đó đến "Default"
      const names = ["Default Profile", "Default"];
      for (const name of names) {
        const folderPath = path.join(profilesDir, name);
        const configPath = path.join(profilesDir, `${name}.config`);
        const jsonPath = path.join(profilesDir, `${name}.json`);

        let foundConfig = "";
        if (fs.existsSync(configPath)) foundConfig = configPath;
        else if (fs.existsSync(jsonPath)) foundConfig = jsonPath;

        if (fs.existsSync(folderPath) || foundConfig) {
          return {
            name: name,
            folder: folderPath,
            config: foundConfig
          };
        }
      }
    } catch (e) {
      console.error("Error getting profile paths:", e);
    }
    return null;
  });

  ipcMain.handle(
    "load-champions",
    async (): Promise<any[]> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        if (!fs.existsSync(filePath)) {
          console.error("Champion data file NOT FOUND at:", filePath);
          return [];
        }
        const data = fs.readFileSync(filePath, "utf-8");
        const allData = JSON.parse(data);
        return allData.map((item: any) => ({
          id: item.id,
          name_en: item.name_en,
          name_vi: item.name_vi
        }));
      } catch (error) {
        console.error("Error loading champions from " + getResourcePath("champion_skins_full.json") + ":", error);
        return [];
      }
    },
  );

  ipcMain.handle(
    "load-skins",
    async (_event, championId: string): Promise<any> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        const data = fs.readFileSync(filePath, "utf-8");
        const allSkins = JSON.parse(data);
        return allSkins.find((item: any) => item.id === championId) || null;
      } catch (error) {
        console.error("Error loading skins:", error);
        return null;
      }
    }
  );
};

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    height: 640,
    width: 960,
    minHeight: 560,
    minWidth: 900,
    icon: path.join(app.getAppPath(), 'assets', 'icon.ico'),
    autoHideMenuBar: true,
    backgroundColor: "#ffffff",
    title: "CS-LOL Launcher",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      sandbox: false,
      webSecurity: false,
    },
  });

  // Set Content Security Policy via headers
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; " +
          "img-src 'self' data: file: blob: https://*.leagueoflegends.com; " +
          "script-src 'self' 'unsafe-eval'; " +
          "style-src 'self' 'unsafe-inline'; " +
          "connect-src 'self' ws: wss:;"
        ]
      }
    });
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools({ mode: "detach" });
  }
};

app.whenReady().then(() => {
  registerIpcHandlers();
  createWindow();

  // Cấu hình Update: Không tự động tải, để user cho phép mới tải
  autoUpdater.autoDownload = false;

  ipcMain.handle("launcher:check-for-updates", async () => {
    if (app.isPackaged) {
      try {
        return await autoUpdater.checkForUpdates();
      } catch (err: any) {
        log.error("Update System: Check failed:", err.message);
        return { success: false, message: err.message };
      }
    }
    return { success: false, message: "Only available in packaged app" };
  });

  autoUpdater.on("update-available", (info) => {
    dialog.showMessageBox({
      type: "info",
      title: "Cập nhật mới",
      message: `Phiên bản ${info.version} đã sẵn sàng. Bạn có muốn tải về ngay không?`,
      buttons: ["Tải về", "Để sau"]
    }).then((result) => {
      if (result.response === 0) {
        autoUpdater.downloadUpdate();
      }
    });
  });

  autoUpdater.on("update-not-available", () => {
    console.log("No updates available.");
  });

  autoUpdater.on("update-downloaded", (info) => {
    dialog.showMessageBox({
      type: "info",
      title: "Tải xong",
      message: `Bản cập nhật ${info.version} đã tải xong. Khởi động lại ứng dụng để áp dụng?`,
      buttons: ["Khởi động lại", "Để sau"]
    }).then((result) => {
      if (result.response === 0) {
        autoUpdater.quitAndInstall();
      }
    });
  });

  autoUpdater.on("error", (err) => {
    console.error("Auto-updater error:", err);
  });

  // Tự động kiểm tra khi mở App
  if (app.isPackaged) {
    autoUpdater.checkForUpdates();
  }

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
