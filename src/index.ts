import { app, BrowserWindow, dialog, ipcMain } from "electron";
import { autoUpdater } from "electron-updater";
import { spawn } from "child_process";
import * as fs from "fs";
import * as path from "path";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const SETTINGS_FILE = path.join(app.getPath("userData"), "settings.json");

const getResourcePath = (filename: string) => {
  return app.isPackaged
    ? path.join(process.resourcesPath, filename)
    : path.join(app.getAppPath(), filename);
};

type Settings = {
  managerPath: string;
  skinsRepoPath: string;
};

type FileDialogResult = { canceled: true } | { canceled: false; path: string };
type LaunchResult = { success: boolean; message?: string };
const registerIpcHandlers = (): void => {
  ipcMain.handle("launcher:select-folder", async (): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select Folder",
      properties: ["openDirectory"],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:select-file", async (_event, filters: any): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select File",
      properties: ["openFile"],
      filters: filters,
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:save-settings", async (_event, settings: Settings) => {
    fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    return true;
  });

  ipcMain.handle("launcher:load-settings", async (): Promise<Settings> => {
    if (fs.existsSync(SETTINGS_FILE)) {
      return JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    }
    return { managerPath: "", skinsRepoPath: "" };
  });

  ipcMain.handle("launcher:find-mod-file", async (_event, championId: string, skinNameEn: string, skinNum: number): Promise<string | null> => {
    if (!fs.existsSync(SETTINGS_FILE)) return null;
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return null;

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return null;

    const files = fs.readdirSync(champDir);

    // 1. Try exact match with En name (e.g. "Justicar Aatrox.zip")
    const exactMatch = files.find(f => f.toLowerCase() === `${skinNameEn.toLowerCase()}.zip` || f.toLowerCase() === `${skinNameEn.toLowerCase()}.fantome`);
    if (exactMatch) return path.join(champDir, exactMatch);

    // 2. Default skin (index 0)
    if (skinNum === 0) {
      const defaultFile = files.find(f => f.toLowerCase() === `${championId.toLowerCase()}.zip` || f.toLowerCase() === `${championId.toLowerCase()}.fantome`);
      if (defaultFile) return path.join(champDir, defaultFile);
    }

    // 3. Fallback: Check if file contains the skin name parts
    const partialMatch = files.find(f => {
      const lowerF = f.toLowerCase();
      const lowerName = skinNameEn.toLowerCase();
      return (lowerF.includes(lowerName) || lowerName.includes(lowerF.replace(/\.(zip|fantome)$/, ""))) && (f.endsWith(".zip") || f.endsWith(".fantome"));
    });

    if (partialMatch) return path.join(champDir, partialMatch);

    return null;
  });

  ipcMain.handle("launcher:list-mod-files", async (_event, championId: string): Promise<string[]> => {
    if (!fs.existsSync(SETTINGS_FILE)) return [];
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return [];

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return [];

    return fs.readdirSync(champDir)
      .filter(f => f.endsWith(".zip") || f.endsWith(".fantome"))
      .map(f => path.join(champDir, f));
  });

  ipcMain.handle("launcher:get-game-path", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) return "";

    const configPath = path.join(settings.managerPath, "config.yaml");
    if (fs.existsSync(configPath)) {
      try {
        const content = fs.readFileSync(configPath, "utf-8");
        // Tìm dòng 'game: ...' trong file yaml
        const match = content.match(/^game:\s*(.*)$/m);
        if (match && match[1]) {
          return match[1].trim().replace(/^"(.*)"$/, '$1'); // Bỏ ngoặc kép nếu có
        }
      } catch (e) {
        console.error("Error reading manager config.yaml:", e);
      }
    }
    return "";
  });

  ipcMain.handle("launcher:run-mod-tools", async (_event, command: string, args: string[]) => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const modToolsPath = path.join(settings.managerPath, "cslol-tools", "mod-tools.exe");
    if (!fs.existsSync(modToolsPath)) throw new Error("mod-tools.exe not found");

    return new Promise((resolve, reject) => {
      const child = spawn(modToolsPath, [command, ...args]);
      let stdout = "";
      let stderr = "";

      child.stdout.on("data", (data) => (stdout += data.toString()));
      child.stderr.on("data", (data) => (stderr += data.toString()));

      child.on("close", (code) => {
        if (code === 0) {
          resolve({ success: true, stdout });
        } else {
          resolve({ success: false, stdout, stderr, code });
        }
      });

      child.on("error", (err) => {
        reject(err);
      });
    });
  });

  ipcMain.handle("launcher:start-manager", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const managerExe = path.join(settings.managerPath, "cslol-manager.exe");
    if (!fs.existsSync(managerExe)) throw new Error("cslol-manager.exe not found");

    const { exec } = require("child_process");
    exec(`"${managerExe}"`, (err: any) => {
      if (err) console.error("Failed to start manager GUI:", err);
    });
    return true;
  });

  ipcMain.handle("launcher:clear-mods", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const installedDir = path.join(settings.managerPath, "installed");
    if (fs.existsSync(installedDir)) {
      const files = fs.readdirSync(installedDir);
      for (const file of files) {
        const fullPath = path.join(installedDir, file);
        try {
          if (fs.lstatSync(fullPath).isDirectory()) {
            fs.rmSync(fullPath, { recursive: true, force: true });
          } else {
            fs.unlinkSync(fullPath);
          }
        } catch (e) {
          console.warn(`Could not delete ${file}:`, e);
        }
      }
    }
    return true;
  });

  ipcMain.handle(
    "load-champions",
    async (): Promise<any[]> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        if (!fs.existsSync(filePath)) {
          console.error("Champion data file NOT FOUND at:", filePath);
          return [];
        }
        const data = fs.readFileSync(filePath, "utf-8");
        const allData = JSON.parse(data);
        return allData.map((item: any) => ({
          id: item.id,
          name_en: item.name_en,
          name_vi: item.name_vi
        }));
      } catch (error) {
        console.error("Error loading champions from " + getResourcePath("champion_skins_full.json") + ":", error);
        return [];
      }
    },
  );

  ipcMain.handle(
    "load-skins",
    async (_event, championId: string): Promise<any> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        const data = fs.readFileSync(filePath, "utf-8");
        const allSkins = JSON.parse(data);
        return allSkins.find((item: any) => item.id === championId) || null;
      } catch (error) {
        console.error("Error loading skins:", error);
        return null;
      }
    }
  );
};

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    height: 640,
    width: 960,
    minHeight: 560,
    minWidth: 900,
    autoHideMenuBar: true,
    backgroundColor: "#ffffff",
    title: "CS-LOL Launcher",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      sandbox: false,
      webSecurity: false,
    },
  });

  // Set Content Security Policy via headers
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; " +
          "img-src 'self' data: file: blob: https://*.leagueoflegends.com; " +
          "script-src 'self' 'unsafe-eval'; " +
          "style-src 'self' 'unsafe-inline'; " +
          "connect-src 'self' ws: wss:;"
        ]
      }
    });
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools({ mode: "detach" });
  }
};

app.whenReady().then(() => {
  registerIpcHandlers();
  createWindow();

  // Basic Auto-update configuration
  if (app.isPackaged) {
    autoUpdater.checkForUpdatesAndNotify();
  }

  autoUpdater.on("update-available", () => {
    console.log("Update available.");
  });

  autoUpdater.on("update-downloaded", () => {
    dialog.showMessageBox({
      type: "info",
      title: "Update Available",
      message: "A new version has been downloaded. Restart the application to apply the updates?",
      buttons: ["Restart", "Later"]
    }).then((result) => {
      if (result.response === 0) {
        autoUpdater.quitAndInstall();
      }
    });
  });

  autoUpdater.on("error", (err) => {
    console.error("Auto-updater error:", err);
  });

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
