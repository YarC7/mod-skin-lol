import { app, BrowserWindow, dialog, ipcMain } from "electron";
import { autoUpdater } from "electron-updater";
import { spawn } from "child_process";
import * as fs from "fs";
import * as path from "path";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const SETTINGS_FILE = path.join(app.getPath("userData"), "settings.json");

const getResourcePath = (filename: string) => {
  return app.isPackaged
    ? path.join(process.resourcesPath, filename)
    : path.join(app.getAppPath(), filename);
};

type Settings = {
  managerPath: string;
  skinsRepoPath: string;
};

type FileDialogResult = { canceled: true } | { canceled: false; path: string };
type LaunchResult = { success: boolean; message?: string };
const registerIpcHandlers = (): void => {
  ipcMain.handle("launcher:select-folder", async (): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select Folder",
      properties: ["openDirectory"],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:select-file", async (_event, filters: any): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select File",
      properties: ["openFile"],
      filters: filters,
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle("launcher:save-settings", async (_event, settings: Settings) => {
    fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));
    return true;
  });

  ipcMain.handle("launcher:load-settings", async (): Promise<Settings> => {
    if (fs.existsSync(SETTINGS_FILE)) {
      return JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    }
    return { managerPath: "", skinsRepoPath: "" };
  });

  ipcMain.handle("launcher:find-mod-file", async (_event, championId: string, skinNameEn: string, skinNum: number): Promise<string | null> => {
    if (!fs.existsSync(SETTINGS_FILE)) return null;
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return null;

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return null;

    const files = fs.readdirSync(champDir);

    // 1. Try exact match with En name (e.g. "Justicar Aatrox.zip")
    const exactMatch = files.find(f => f.toLowerCase() === `${skinNameEn.toLowerCase()}.zip` || f.toLowerCase() === `${skinNameEn.toLowerCase()}.fantome`);
    if (exactMatch) return path.join(champDir, exactMatch);

    // 2. Default skin (index 0)
    if (skinNum === 0) {
      const defaultFile = files.find(f => f.toLowerCase() === `${championId.toLowerCase()}.zip` || f.toLowerCase() === `${championId.toLowerCase()}.fantome`);
      if (defaultFile) return path.join(champDir, defaultFile);
    }

    // 3. Fallback: Check if file contains the skin name parts
    const partialMatch = files.find(f => {
      const lowerF = f.toLowerCase();
      const lowerName = skinNameEn.toLowerCase();
      return (lowerF.includes(lowerName) || lowerName.includes(lowerF.replace(/\.(zip|fantome)$/, ""))) && (f.endsWith(".zip") || f.endsWith(".fantome"));
    });

    if (partialMatch) return path.join(champDir, partialMatch);

    return null;
  });

  ipcMain.handle("launcher:list-mod-files", async (_event, championId: string): Promise<string[]> => {
    if (!fs.existsSync(SETTINGS_FILE)) return [];
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.skinsRepoPath) return [];

    const champDir = path.join(settings.skinsRepoPath, "skins", championId);
    if (!fs.existsSync(champDir)) return [];

    return fs.readdirSync(champDir)
      .filter(f => f.endsWith(".zip") || f.endsWith(".fantome"))
      .map(f => path.join(champDir, f));
  });

  ipcMain.handle("launcher:get-game-path", async () => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return "";
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return "";

      const configPath = path.join(settings.managerPath, "config.yaml");
      if (fs.existsSync(configPath)) {
        const content = fs.readFileSync(configPath, "utf-8");
        const match = content.match(/game(?:Path)?:\s*["']?(.*?)["']?$/m);
        if (match && match[1]) {
          let p = match[1].trim();
          if (p) {
            console.log("Detected game path from config.yaml:", p);
            return p;
          }
        }
      }
    } catch (e) {
      console.error("Error detecting game path:", e);
    }
    return "";
  });

  ipcMain.handle("launcher:run-mod-tools", async (_event, command: string, args: string[]) => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const modToolsPath = path.join(settings.managerPath, "cslol-tools", "mod-tools.exe");
    if (!fs.existsSync(modToolsPath)) throw new Error("mod-tools.exe not found");

    return new Promise((resolve, reject) => {
      const child = spawn(modToolsPath, [command, ...args], {
        cwd: settings.managerPath
      });
      let stdout = "";
      let stderr = "";

      child.stdout.on("data", (data) => (stdout += data.toString()));
      child.stderr.on("data", (data) => (stderr += data.toString()));

      child.on("close", (code) => {
        if (code === 0) {
          resolve({ success: true, stdout });
        } else {
          resolve({ success: false, stdout, stderr, code });
        }
      });

      child.on("error", (err) => {
        reject(err);
      });
    });
  });

  ipcMain.handle("launcher:kill-manager", async () => {
    const { exec } = require("child_process");
    return new Promise((resolve) => {
      // /F: Force kill, /IM: Image Name, /T: Kill child processes
      exec('taskkill /F /IM cslol-manager.exe /T', () => {
        // Luôn resolve true kể cả khi nó không chạy (lỗi thoát code 128)
        resolve(true);
      });
    });
  });

  ipcMain.handle("launcher:start-manager", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const managerExe = path.join(settings.managerPath, "cslol-manager.exe");
    if (!fs.existsSync(managerExe)) throw new Error("cslol-manager.exe not found");

    const { exec } = require("child_process");

    // Kiểm tra xem tiến trình có đang chạy không
    return new Promise((resolve) => {
      exec('tasklist', (err: any, stdout: string) => {
        // Kiểm tra đúng tên file exe (có thể là cs-lol-manager.exe hoặc cslol-manager.exe)
        // Dựa vào code của bạn đang để là cslol-manager.exe
        const isRunning = stdout.toLowerCase().includes("cslol-manager.exe");

        if (isRunning) {
          console.log("CS-LOL Manager is already running.");
          resolve(true);
        } else {
          // Chỉ mở nếu chưa chạy
          exec(`"${managerExe}"`, (startErr: any) => {
            if (startErr) console.error("Failed to start manager GUI:", startErr);
            resolve(true);
          });
        }
      });
    });
  });

  ipcMain.handle("launcher:clear-mods", async () => {
    const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
    if (!settings.managerPath) throw new Error("Manager path not set");

    const installedDir = path.join(settings.managerPath, "installed");
    if (fs.existsSync(installedDir)) {
      const files = fs.readdirSync(installedDir);
      for (const file of files) {
        const fullPath = path.join(installedDir, file);
        try {
          if (fs.lstatSync(fullPath).isDirectory()) {
            fs.rmSync(fullPath, { recursive: true, force: true });
          } else {
            fs.unlinkSync(fullPath);
          }
        } catch (e) {
          console.warn(`Could not delete ${file}:`, e);
        }
      }
    }
    return true;
  });

  ipcMain.handle("launcher:enable-mod-in-profile", async (_event, modName: string) => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return false;
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return false;

      const profilesDir = path.join(settings.managerPath, "profiles");
      if (!fs.existsSync(profilesDir)) return false;

      // Tìm tất cả các file liên quan đến profile (Default, Default Profile, v.v.)
      const files = fs.readdirSync(profilesDir);

      for (const file of files) {
        const fullPath = path.join(profilesDir, file);
        const lowerFile = file.toLowerCase();

        // 1. Xử lý file .profile (Dạng text thuần, mỗi dòng 1 tên mod)
        if (lowerFile.endsWith(".profile")) {
          console.log(`Updating .profile file: ${file}`);
          fs.writeFileSync(fullPath, modName + "\n");
        }

        // 2. Xử lý file .config hoặc .json (Dạng JSON)
        else if (lowerFile.endsWith(".config") || lowerFile.endsWith(".json")) {
          console.log(`Updating JSON config: ${file}`);
          try {
            let config: any = { mods: {} };
            const content = fs.readFileSync(fullPath, "utf-8");
            if (content.trim()) {
              try { config = JSON.parse(content); } catch (e) { /* ignore */ }
            }
            config.mods = {};
            config.mods[modName] = true;
            fs.writeFileSync(fullPath, JSON.stringify(config, null, 2));
          } catch (e) { console.warn(e); }
        }

        // 3. Xử lý thư mục profile (Chứa config.yaml bên trong)
        else if (fs.lstatSync(fullPath).isDirectory()) {
          const yamlPath = path.join(fullPath, "config.yaml");
          if (fs.existsSync(yamlPath)) {
            console.log(`Updating YAML config in folder: ${file}`);
            let content = fs.readFileSync(yamlPath, "utf-8");
            if (content.includes("mods:")) {
              content = content.replace(/mods:[\s\S]*?(?=\n\w|$)/, `mods:\n  ${modName}: true`);
            } else {
              content += `\nmods:\n  ${modName}: true`;
            }
            fs.writeFileSync(yamlPath, content);
          }
        }
      }
      return true;
    } catch (e) {
      console.error("Error in enable-mod-in-profile:", e);
      return false;
    }
  });

  ipcMain.handle("launcher:get-profile-paths", async () => {
    try {
      if (!fs.existsSync(SETTINGS_FILE)) return null;
      const settings: Settings = JSON.parse(fs.readFileSync(SETTINGS_FILE, "utf-8"));
      if (!settings.managerPath) return null;

      const profilesDir = path.join(settings.managerPath, "profiles");
      if (!fs.existsSync(profilesDir)) return null;

      // Ưu tiên "Default Profile" sau đó đến "Default"
      const names = ["Default Profile", "Default"];
      for (const name of names) {
        const folderPath = path.join(profilesDir, name);
        const configPath = path.join(profilesDir, `${name}.config`);
        const jsonPath = path.join(profilesDir, `${name}.json`);

        let foundConfig = "";
        if (fs.existsSync(configPath)) foundConfig = configPath;
        else if (fs.existsSync(jsonPath)) foundConfig = jsonPath;

        if (fs.existsSync(folderPath) || foundConfig) {
          return {
            name: name,
            folder: folderPath,
            config: foundConfig
          };
        }
      }
    } catch (e) {
      console.error("Error getting profile paths:", e);
    }
    return null;
  });

  ipcMain.handle(
    "load-champions",
    async (): Promise<any[]> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        if (!fs.existsSync(filePath)) {
          console.error("Champion data file NOT FOUND at:", filePath);
          return [];
        }
        const data = fs.readFileSync(filePath, "utf-8");
        const allData = JSON.parse(data);
        return allData.map((item: any) => ({
          id: item.id,
          name_en: item.name_en,
          name_vi: item.name_vi
        }));
      } catch (error) {
        console.error("Error loading champions from " + getResourcePath("champion_skins_full.json") + ":", error);
        return [];
      }
    },
  );

  ipcMain.handle(
    "load-skins",
    async (_event, championId: string): Promise<any> => {
      try {
        const filePath = getResourcePath("champion_skins_full.json");
        const data = fs.readFileSync(filePath, "utf-8");
        const allSkins = JSON.parse(data);
        return allSkins.find((item: any) => item.id === championId) || null;
      } catch (error) {
        console.error("Error loading skins:", error);
        return null;
      }
    }
  );
};

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    height: 640,
    width: 960,
    minHeight: 560,
    minWidth: 900,
    autoHideMenuBar: true,
    backgroundColor: "#ffffff",
    title: "CS-LOL Launcher",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      sandbox: false,
      webSecurity: false,
    },
  });

  // Set Content Security Policy via headers
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; " +
          "img-src 'self' data: file: blob: https://*.leagueoflegends.com; " +
          "script-src 'self' 'unsafe-eval'; " +
          "style-src 'self' 'unsafe-inline'; " +
          "connect-src 'self' ws: wss:;"
        ]
      }
    });
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools({ mode: "detach" });
  }
};

app.whenReady().then(() => {
  registerIpcHandlers();
  createWindow();

  // Cấu hình Update: Không tự động tải, để user cho phép mới tải
  autoUpdater.autoDownload = false;

  ipcMain.handle("launcher:check-for-updates", async () => {
    if (app.isPackaged) {
      return autoUpdater.checkForUpdates();
    }
    return { success: false, message: "Only available in packaged app" };
  });

  autoUpdater.on("update-available", (info) => {
    dialog.showMessageBox({
      type: "info",
      title: "Cập nhật mới",
      message: `Phiên bản ${info.version} đã sẵn sàng. Bạn có muốn tải về ngay không?`,
      buttons: ["Tải về", "Để sau"]
    }).then((result) => {
      if (result.response === 0) {
        autoUpdater.downloadUpdate();
      }
    });
  });

  autoUpdater.on("update-not-available", () => {
    console.log("No updates available.");
  });

  autoUpdater.on("update-downloaded", (info) => {
    dialog.showMessageBox({
      type: "info",
      title: "Tải xong",
      message: `Bản cập nhật ${info.version} đã tải xong. Khởi động lại ứng dụng để áp dụng?`,
      buttons: ["Khởi động lại", "Để sau"]
    }).then((result) => {
      if (result.response === 0) {
        autoUpdater.quitAndInstall();
      }
    });
  });

  autoUpdater.on("error", (err) => {
    console.error("Auto-updater error:", err);
  });

  // Tự động kiểm tra khi mở App
  if (app.isPackaged) {
    autoUpdater.checkForUpdates();
  }

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
