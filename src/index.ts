import { app, BrowserWindow, dialog, ipcMain } from "electron";
import { spawn } from "child_process";
import * as fs from "fs";
import * as path from "path";
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

type FileDialogResult = { canceled: true } | { canceled: false; path: string };
type LaunchResult = { success: boolean; message?: string };

const registerIpcHandlers = (): void => {
  ipcMain.handle("launcher:select-exe", async (): Promise<FileDialogResult> => {
    const result = await dialog.showOpenDialog({
      title: "Select CS-LOL Manager Executable",
      properties: ["openFile"],
      filters: [
        { name: "Executable Files", extensions: ["exe", "bat", "cmd"] },
        { name: "All Files", extensions: ["*"] },
      ],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return { canceled: true };
    }

    return {
      canceled: false,
      path: result.filePaths[0],
    };
  });

  ipcMain.handle(
    "launcher:run-exe",
    async (_event, executablePath: string): Promise<LaunchResult> => {
      if (!executablePath) {
        return {
          success: false,
          message: "No executable selected.",
        };
      }

      return await new Promise<LaunchResult>((resolve) => {
        try {
          const child = spawn(executablePath, {
            detached: true,
            stdio: "ignore",
            windowsHide: false,
          });

          let resolved = false;
          const complete = (result: LaunchResult): void => {
            if (resolved) {
              return;
            }

            resolved = true;
            resolve(result);
          };

          child.once("error", (error) => {
            complete({
              success: false,
              message:
                error instanceof Error
                  ? error.message
                  : "Unable to start CS-LOL Manager.",
            });
          });

          child.once("spawn", () => {
            child.unref();
            complete({ success: true });
          });
        } catch (error) {
          resolve({
            success: false,
            message:
              error instanceof Error
                ? error.message
                : "Unable to start CS-LOL Manager.",
          });
        }
      });
    },
  );

  ipcMain.handle(
    "load-champions",
    async (): Promise<{ name: string; icon: string }[]> => {
      try {
        const filePath = path.join(app.getAppPath(), "champions.json");
        const data = fs.readFileSync(filePath, "utf-8");
        return JSON.parse(data);
      } catch (error) {
        console.error("Error loading champions:", error);
        return [];
      }
    },
  );

  ipcMain.handle(
    "load-skins",
    async (_event, championId: string): Promise<any> => {
      try {
        const filePath = path.join(app.getAppPath(), "champion_skins.json");
        const data = fs.readFileSync(filePath, "utf-8");
        const allSkins = JSON.parse(data);
        return allSkins.find((item: any) => item.championId === championId) || null;
      } catch (error) {
        console.error("Error loading skins:", error);
        return null;
      }
    }
  );
};

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    height: 640,
    width: 960,
    minHeight: 560,
    minWidth: 900,
    autoHideMenuBar: true,
    backgroundColor: "#ffffff",
    title: "CS-LOL Launcher",
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      sandbox: false,
      webSecurity: false,
    },
  });

  // Set Content Security Policy via headers
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; " +
          "img-src 'self' data: file: blob: https://*.leagueoflegends.com; " +
          "script-src 'self' 'unsafe-eval'; " +
          "style-src 'self' 'unsafe-inline'; " +
          "connect-src 'self' ws: wss:;"
        ]
      }
    });
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  if (!app.isPackaged) {
    mainWindow.webContents.openDevTools({ mode: "detach" });
  }
};

app.whenReady().then(() => {
  registerIpcHandlers();
  createWindow();

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
